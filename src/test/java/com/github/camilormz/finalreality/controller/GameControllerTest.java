package com.github.camilormz.finalreality.controller;

import com.github.camilormz.finalreality.model.character.CharacterDomain;
import com.github.camilormz.finalreality.model.character.Enemy;
import com.github.camilormz.finalreality.model.character.ICharacter;
import com.github.camilormz.finalreality.model.character.player.CharacterClass;
import com.github.camilormz.finalreality.model.character.player.IPlayerCharacter;
import com.github.camilormz.finalreality.model.character.player.characterclass.*;
import com.github.camilormz.finalreality.model.weapon.IWeapon;
import com.github.camilormz.finalreality.model.weapon.WeaponType;
import com.github.camilormz.finalreality.model.weapon.types.*;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.Set;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Test class that holds everything related to the controller
 *
 * @author Camilo Ram√≠rez Canales
 */
public class GameControllerTest {

    private GameController controller;
    private BlockingQueue<ICharacter> turns;

    // Constant Strings for character names
    private final String BLACK_MAGE_NAME = "Nix";
    private final String BLACK_MAGE_NAME_2 = "Chaos";
    private final String ENGINEER_NAME = "Tesla";
    private final String KNIGHT_NAME = "Steel";
    private final String THIEF_NAME = "Bonnie";
    private final String WHITE_MAGE_NAME = "Lux";

    private final String AXE_NAME = "Wood Slayer";
    private final String BOW_NAME = "The Trebuchet";
    private final String KNIFE_NAME = "Stealthy";
    private final String STAFF_NAME = "Shadowmaker";
    private final String SWORD_NAME = "Infidel Redentor";

    private final String ENEMY_NAME = "Kronos";
    private final String ENEMY_NAME_2 = "Goblin";
    private final String ENEMY_NAME_3 = "Venom";

    // Characters generated directly by model constructors
    private BlackMage modelBlackMage;
    private Engineer modelEngineer;
    private Knight modelKnight;
    private Thief modelThief;
    private WhiteMage modelWhiteMage;

    private Enemy modelEnemy;

    private Axe modelAxe;
    private Bow modelBow;
    private Knife modelKnife;
    private Staff modelStaff;
    private Sword modelSword;

    // Characters generated by the controller
    private BlackMage controllerBlackMage;
    private BlackMage controllerPoweredBlackMage;
    private Engineer controllerEngineer;
    private Knight controllerKnight;
    private Thief controllerThief;
    private WhiteMage controllerWhiteMage;

    private Enemy controllerEnemy;
    private Enemy controllerEnemy2;
    private Enemy controllerEnemy3;
    private Enemy controllerPoweredEnemy;

    private Axe controllerAxe;
    private Bow controllerBow;
    private Knife controllerKnife;
    private Staff controllerStaff;
    private Staff controllerPoweredStaff;
    private Sword controllerSword;

    // Default values for test characters
    private final int DEFAULT_HEALTH_POINTS = 100;
    private final int DEFAULT_DEFENSE = 2;
    private final int DEFAULT_ENEMY_WEIGHT = 10;
    private final int DEFAULT_WEAPON_WEIGHT = 10;
    private final int DEFAULT_ENEMY_DAMAGE = 10;
    private final int DEFAULT_WEAPON_DAMAGE = 10;
    private final int DEFAULT_MAGIC_DAMAGE = 10;

    // Winners name
    private final String WINNER_NOBODY = GameController.WINNER_NOBODY;
    private final String WINNER_PLAYER = GameController.WINNER_PLAYER;
    private final String WINNER_CPU = GameController.WINNER_CPU;
    private final String WINNER_TIE = GameController.WINNER_TIE;

    // Milliseconds to wait in the enqueuing test at 0 expected time
    private final long epsilonWaitTurnTest = 50;

    /**
     * Initializes every variable necessary to do the tests, e.g., characters, weapons,
     * the controller, the turns queue among others
     */
    @BeforeEach
    void setUp() {
        controller = new GameController();
        turns = new LinkedBlockingQueue<>();

        modelBlackMage = new BlackMage(BLACK_MAGE_NAME, DEFAULT_HEALTH_POINTS,
                                       DEFAULT_DEFENSE, turns);
        modelEngineer = new Engineer(ENGINEER_NAME, DEFAULT_HEALTH_POINTS, DEFAULT_DEFENSE, turns);
        modelKnight = new Knight(KNIGHT_NAME, DEFAULT_HEALTH_POINTS, DEFAULT_DEFENSE, turns);
        modelThief = new Thief(THIEF_NAME, DEFAULT_HEALTH_POINTS, DEFAULT_DEFENSE, turns);
        modelWhiteMage = new WhiteMage(WHITE_MAGE_NAME, DEFAULT_HEALTH_POINTS,
                                       DEFAULT_DEFENSE, turns);

        modelEnemy = new Enemy(ENEMY_NAME, DEFAULT_ENEMY_WEIGHT, DEFAULT_HEALTH_POINTS,
                               DEFAULT_DEFENSE, DEFAULT_ENEMY_DAMAGE, turns);

        modelAxe = new Axe(AXE_NAME, DEFAULT_WEAPON_DAMAGE, DEFAULT_WEAPON_WEIGHT);
        modelBow = new Bow(BOW_NAME, DEFAULT_WEAPON_DAMAGE, DEFAULT_ENEMY_WEIGHT);
        modelKnife = new Knife(KNIFE_NAME, DEFAULT_WEAPON_DAMAGE, DEFAULT_WEAPON_WEIGHT);
        modelStaff = new Staff(STAFF_NAME, DEFAULT_WEAPON_DAMAGE,
                               DEFAULT_WEAPON_WEIGHT, DEFAULT_MAGIC_DAMAGE);
        modelSword = new Sword(SWORD_NAME, DEFAULT_WEAPON_DAMAGE, DEFAULT_WEAPON_WEIGHT);

        controllerBlackMage = controller.createBlackMage(BLACK_MAGE_NAME,
                                                         DEFAULT_HEALTH_POINTS, DEFAULT_DEFENSE);
        controllerPoweredBlackMage = controller.createBlackMage(BLACK_MAGE_NAME_2,
                                                                DEFAULT_HEALTH_POINTS,
                                                                DEFAULT_DEFENSE);
        controllerEngineer = controller.createEngineer(ENGINEER_NAME,
                                                       DEFAULT_HEALTH_POINTS, DEFAULT_DEFENSE);
        controllerKnight = controller.createKnight(KNIGHT_NAME,
                                                   DEFAULT_HEALTH_POINTS, DEFAULT_DEFENSE);
        controllerThief = controller.createThief(THIEF_NAME,
                                                 DEFAULT_HEALTH_POINTS, DEFAULT_DEFENSE);
        controllerWhiteMage = controller.createWhiteMage(WHITE_MAGE_NAME,
                                                         DEFAULT_HEALTH_POINTS, DEFAULT_DEFENSE);

        controllerEnemy = controller.createEnemy(ENEMY_NAME, DEFAULT_ENEMY_WEIGHT,
                                                 DEFAULT_HEALTH_POINTS, DEFAULT_DEFENSE,
                                                 DEFAULT_ENEMY_DAMAGE);
        controllerEnemy2 = controller.createEnemy(ENEMY_NAME_2, DEFAULT_ENEMY_WEIGHT,
                                                  DEFAULT_HEALTH_POINTS, DEFAULT_DEFENSE,
                                                  DEFAULT_ENEMY_DAMAGE);
        controllerEnemy3 = controller.createEnemy(ENEMY_NAME_3, DEFAULT_ENEMY_WEIGHT,
                                                  DEFAULT_HEALTH_POINTS, DEFAULT_DEFENSE,
                                                  DEFAULT_ENEMY_DAMAGE);
        controllerPoweredEnemy = controller.createEnemy(ENEMY_NAME, DEFAULT_ENEMY_WEIGHT,
                                                        DEFAULT_HEALTH_POINTS, DEFAULT_DEFENSE,
                                                DEFAULT_ENEMY_DAMAGE*100);

        controllerAxe = controller.createAxe(AXE_NAME,
                                             DEFAULT_WEAPON_DAMAGE, DEFAULT_WEAPON_WEIGHT);
        controllerBow = controller.createBow(BOW_NAME,
                                             DEFAULT_WEAPON_DAMAGE, DEFAULT_WEAPON_WEIGHT);
        controllerKnife = controller.createKnife(KNIFE_NAME,
                                               DEFAULT_WEAPON_DAMAGE, DEFAULT_WEAPON_WEIGHT);
        controllerStaff = controller.createStaff(STAFF_NAME, DEFAULT_WEAPON_DAMAGE,
                                                 DEFAULT_WEAPON_WEIGHT, DEFAULT_MAGIC_DAMAGE);
        controllerPoweredStaff = controller.createStaff(STAFF_NAME,
                                                DEFAULT_WEAPON_DAMAGE*100,
                                                        DEFAULT_MAGIC_DAMAGE, DEFAULT_MAGIC_DAMAGE);
        controllerSword = controller.createSword(SWORD_NAME,
                                                 DEFAULT_WEAPON_DAMAGE, DEFAULT_WEAPON_WEIGHT);

        controller.tryToEquipWeapon(controllerPoweredBlackMage, controllerPoweredStaff);
    }

    /**
     * Tests that the controller can create the model elements (playable characters, enemies and
     * weapons) as exactly as their respective constructor does
     */
    @Test
    void controllerCreationTest() {
        assertEquals(controllerBlackMage, modelBlackMage);
        assertEquals(controllerEngineer, modelEngineer);
        assertEquals(controllerKnight, modelKnight);
        assertEquals(controllerThief, modelThief);
        assertEquals(controllerWhiteMage, modelWhiteMage);

        assertEquals(controllerEnemy, modelEnemy);

        assertEquals(controllerAxe, modelAxe);
        assertEquals(controllerBow, modelBow);
        assertEquals(controllerKnife, modelKnife);
        assertEquals(controllerStaff, modelStaff);
        assertEquals(controllerSword, modelSword);
    }

    /**
     * Tests that the controller getters works as expected
     */
    @Test
    void attributeGetterTest() {
        assertEquals(controller.getCharacterName(controllerWhiteMage), WHITE_MAGE_NAME);
        assertEquals(controller.getCharacterHealthPoints(controllerWhiteMage),
                     DEFAULT_HEALTH_POINTS);
        assertEquals(controller.getCharacterDefense(controllerWhiteMage), DEFAULT_DEFENSE);
        assertEquals(controller.getCharacterDomain(controllerWhiteMage), CharacterDomain.PLAYABLE);

        assertEquals(controller.getPlayableCharacterClass(controllerWhiteMage),
                     CharacterClass.WHITE_MAGE);
        assertNull(controller.getPlayableCharacterEquippedWeapon(controllerWhiteMage));

        assertEquals(controller.getEnemyWeight(controllerEnemy), DEFAULT_ENEMY_WEIGHT);
        assertEquals(controller.getEnemyDamage(controllerEnemy), DEFAULT_ENEMY_DAMAGE);

        assertEquals(controller.getWeaponName(controllerKnife), KNIFE_NAME);
        assertEquals(controller.getWeaponDamage(controllerKnife), DEFAULT_WEAPON_DAMAGE);
        assertEquals(controller.getWeaponWeight(controllerKnife), DEFAULT_WEAPON_WEIGHT);
        assertEquals(controller.getWeaponType(controllerKnife), WeaponType.KNIFE);
        assertNull(controller.getWeaponHolder(controllerKnife));

        assertEquals(controller.getMagicDamage(controllerStaff), DEFAULT_MAGIC_DAMAGE);
    }

    /**
     * Test for playable character assignation to the player to play
     */
    @Test
    void playerAssignationTest() {
        // The assigned characters set starts empty
        Set<IPlayerCharacter> playerAssignedCharacters =
                controller.getPlayerAssignedCharacters();
        assertEquals(playerAssignedCharacters.size(), 0);
        // Assigns a character
        controller.assignToPlayer(controllerKnight);
        assertEquals(playerAssignedCharacters.size(), 1);
        // Assigns a second character and a character already assigned
        controller.assignToPlayer(controllerBlackMage);
        controller.assignToPlayer(modelBlackMage);
        assertEquals(playerAssignedCharacters.size(), 2);
        // Tests that the expected characters are in the set
        assertTrue(playerAssignedCharacters.contains(controllerKnight));
        assertTrue(playerAssignedCharacters.contains(controllerBlackMage));
        assertFalse(playerAssignedCharacters.contains(controllerEngineer));
        // Remove a character and tries to remove one that's already not in the set
        controller.removeFromPlayer(controllerKnight);
        controller.removeFromPlayer(controllerEngineer);
        // Tests that the expected characters are in the set
        assertTrue(playerAssignedCharacters.contains(controllerBlackMage));
        assertFalse(playerAssignedCharacters.contains(controllerKnight));
        assertFalse(playerAssignedCharacters.contains(controllerEngineer));
        assertEquals(playerAssignedCharacters.size(), 1);
    }

    /**
     * Test for enemies assignation to the CPU (enemy player)
     */
    @Test
    void enemyAssignationTest() {
        // The assigned enemy set starts empty
        Set<Enemy> cpuEnemiesAssigned = controller.getEnemiesAssigned();
        assertEquals(cpuEnemiesAssigned.size(), 0);
        // Assigns an enemy
        controller.assignEnemy(controllerEnemy);
        assertEquals(cpuEnemiesAssigned.size(), 1);
        // Assigns a second enemy and an enemy already assigned
        controller.assignEnemy(controllerEnemy2);
        controller.assignEnemy(modelEnemy);
        assertEquals(cpuEnemiesAssigned.size(), 2);
        // Tests that the expected enemies are in the set
        assertTrue(cpuEnemiesAssigned.contains(controllerEnemy));
        assertTrue(cpuEnemiesAssigned.contains(controllerEnemy2));
        assertFalse(cpuEnemiesAssigned.contains(controllerEnemy3));
        // Remove an enemy and tries to remove one that's already not in the set
        controller.removeAssignedEnemy(controllerEnemy);
        controller.removeAssignedEnemy(controllerEnemy3);
        // Tests that the expected enemies are in the set
        assertTrue(cpuEnemiesAssigned.contains(controllerEnemy2));
        assertFalse(cpuEnemiesAssigned.contains(controllerEnemy));
        assertFalse(cpuEnemiesAssigned.contains(controllerEnemy3));
        assertEquals(cpuEnemiesAssigned.size(), 1);
    }

    /**
     * Test for inventory assignation (weapons)
     */
    @Test
    void inventoryTest() {
        // The inventory starts empty
        Set<IWeapon> inventory = controller.getInventory();
        assertEquals(inventory.size(), 0);
        // Assigns a weapon to the inventory
        controller.assignToInventory(controllerSword);
        assertEquals(inventory.size(), 1);
        // Assigns a second weapon and a weapon already assigned
        controller.assignToInventory(controllerStaff);
        controller.assignToInventory(modelSword);
        assertEquals(inventory.size(), 2);
        // Tests that the expected weapons are in the inventory
        assertTrue(inventory.contains(controllerSword));
        assertTrue(inventory.contains(controllerStaff));
        assertFalse(inventory.contains(controllerAxe));
        // Remove a weapon and tries to remove one that's already not in the inventory
        controller.removeFromInventory(controllerSword);
        controller.removeFromInventory(controllerAxe);
        // Tests that the expected weapons are in the inventory
        assertTrue(inventory.contains(controllerStaff));
        assertFalse(inventory.contains(controllerSword));
        assertFalse(inventory.contains(controllerAxe));
        assertEquals(inventory.size(), 1);
    }

    /**
     * Tests that the controller con successfully equip and un-equip a playable character with a
     * weapon, for a complete test on equipment dynamics
     * @see com.github.camilormz.finalreality.model.character.player.AbstractPlayerCharacterTest
     */
    @Test
    void controllerEquipmentTest() {
        // Tests that there is no equipment performed at start
        assertNull(controller.getPlayableCharacterEquippedWeapon(controllerKnight));
        assertNull(controller.getWeaponHolder(controllerSword));
        assertNull(controller.getWeaponHolder(controllerAxe));
        assertNull(controller.getWeaponHolder(controllerStaff));
        // Tests that a knight can equip a sword successfully
        assertTrue(controller.tryToEquipWeapon(controllerKnight, controllerSword));
        assertEquals(controller.getPlayableCharacterEquippedWeapon(controllerKnight),
                     controllerSword);
        assertEquals(controller.getWeaponHolder(controllerSword), controllerKnight);
        // Tests that the knight can change its weapon to an axe
        assertTrue(controller.tryToEquipWeapon(controllerKnight, controllerAxe));
        assertEquals(controller.getPlayableCharacterEquippedWeapon(controllerKnight),
                     controllerAxe);
        assertEquals(controller.getWeaponHolder(controllerAxe), controllerKnight);
        // Tests that a thief can equip the dropped sword and the knight can't equip the already
        // taken sword
        assertTrue(controller.tryToEquipWeapon(controllerThief, controllerSword));
        assertFalse(controller.tryToEquipWeapon(controllerKnight, controllerSword));
        assertEquals(controller.getPlayableCharacterEquippedWeapon(controllerKnight),
                     controllerAxe);
        assertEquals(controller.getPlayableCharacterEquippedWeapon(controllerThief),
                     controllerSword);
        assertEquals(controller.getWeaponHolder(controllerAxe), controllerKnight);
        assertEquals(controller.getWeaponHolder(controllerSword), controllerThief);
        // Tests that the knight can't equip an Staff
        assertFalse(controller.tryToEquipWeapon(controllerKnight, controllerStaff));
        assertEquals(controller.getPlayableCharacterEquippedWeapon(controllerKnight),
                     controllerAxe);
        assertEquals(controller.getWeaponHolder(controllerAxe), controllerKnight);
        assertNull(controller.getWeaponHolder(controllerStaff));
        // Tests knight weapon un-equipment
        controller.unEquipWeapon(controllerKnight);
        assertNull(controller.getPlayableCharacterEquippedWeapon(controllerKnight));
        assertNull(controller.getWeaponHolder(controllerAxe));
        assertEquals(controller.getWeaponHolder(controllerSword), controllerThief);
    }

    /**
     * Tests that the controller can perform a successfully attack in both sides
     * For a complete combat dynamic test
     * @see com.github.camilormz.finalreality.model.character.AbstractCharacterTest
     */
    @Test
    void controllerAttackTest() {
        assertEquals(controller.getCharacterHealthPoints(controllerKnight), DEFAULT_HEALTH_POINTS);
        assertEquals(controller.getCharacterHealthPoints(controllerEnemy), DEFAULT_HEALTH_POINTS);
        controller.tryToEquipWeapon(controllerKnight, controllerSword);
        controller.performAttack(controllerKnight, controllerEnemy);
        controller.performAttack(controllerEnemy, controllerKnight);
        controller.performAttack(controllerEnemy, controllerKnight);
        assertEquals(controller.getCharacterHealthPoints(controllerKnight),
              DEFAULT_HEALTH_POINTS - 2*(DEFAULT_ENEMY_DAMAGE - DEFAULT_DEFENSE));
        assertEquals(controller.getCharacterHealthPoints(controllerEnemy),
              DEFAULT_HEALTH_POINTS - (DEFAULT_WEAPON_DAMAGE - DEFAULT_DEFENSE));
    }

    /**
     * Tests that the methods for combat availability of assigned players and enemies works as
     * expected, also checks that the game detects correctly the winner
     */
    @Test
    void availabilityTest() {
        // Get assigned character sets
        Set<IPlayerCharacter> playerAssignedCharacters = controller.getPlayerAssignedCharacters();
        Set<Enemy> cpuEnemiesAssigned = controller.getEnemiesAssigned();
        // Checks that the is no currently a winner
        assertEquals(controller.getWinner(), WINNER_NOBODY);
        // Checks that every character is ready to combat
        assertTrue(controller.checkCombatAvailability(controllerKnight));
        assertTrue(controller.checkCombatAvailability(controllerWhiteMage));
        assertTrue(controller.checkCombatAvailability(controllerEnemy));
        assertTrue(controller.checkCombatAvailability(controllerEnemy2));
        assertTrue(controller.checkCombatAvailability(controllerEnemy3));
        // Assigns the characters to their respective players
        controller.assignToPlayer(controllerKnight);
        controller.assignToPlayer(controllerWhiteMage);
        controller.assignEnemy(controllerEnemy);
        controller.assignEnemy(controllerEnemy2);
        controller.assignEnemy(controllerEnemy3);
        // Updates the winners and checks that there is nobody winning yet
        controller.updateWinner();
        assertEquals(controller.getWinner(), WINNER_NOBODY);
        // Checks that nobody has won the game yet
        // Checks that both players have the correct amount of available characters assigned
        assertEquals(controller.countAvailableForCombat(playerAssignedCharacters), 2);
        assertEquals(controller.countAvailableForCombat(cpuEnemiesAssigned), 3);
        assertTrue(controller.isAnyAvailableForCombat(playerAssignedCharacters));
        assertTrue(controller.isAnyAvailableForCombat(cpuEnemiesAssigned));
        // K.O.s a playable character and a enemy
        controller.performAttack(controllerPoweredBlackMage, controllerEnemy);
        controller.performAttack(controllerPoweredEnemy, controllerKnight);
        // Checks that both players have the correct amount of available characters assigned
        assertEquals(controller.countAvailableForCombat(playerAssignedCharacters), 1);
        assertEquals(controller.countAvailableForCombat(cpuEnemiesAssigned), 2);
        assertTrue(controller.isAnyAvailableForCombat(playerAssignedCharacters));
        assertTrue(controller.isAnyAvailableForCombat(cpuEnemiesAssigned));
        // K.O.s another playable character and another enemy
        controller.performAttack(controllerPoweredBlackMage, controllerEnemy2);
        controller.performAttack(controllerPoweredEnemy, controllerWhiteMage);
        // Checks that both players have the correct amount of available characters assigned
        assertEquals(controller.countAvailableForCombat(playerAssignedCharacters), 0);
        assertEquals(controller.countAvailableForCombat(cpuEnemiesAssigned), 1);
        assertFalse(controller.isAnyAvailableForCombat(playerAssignedCharacters));
        assertTrue(controller.isAnyAvailableForCombat(cpuEnemiesAssigned));
        // Checks that the knocked out characters are not ready for combat and that the remaining
        // enemy is in the other hand ready for combat
        assertFalse(controller.checkCombatAvailability(controllerKnight));
        assertFalse(controller.checkCombatAvailability(controllerWhiteMage));
        assertFalse(controller.checkCombatAvailability(controllerEnemy));
        assertFalse(controller.checkCombatAvailability(controllerEnemy2));
        assertTrue(controller.checkCombatAvailability(controllerEnemy3));
        // Checks that the player and the CPU still have 2 and 3 assigned characters respectively
        assertEquals(playerAssignedCharacters.size(), 2);
        assertEquals(cpuEnemiesAssigned.size(), 3);
        // Checks that the CPU has won
        controller.updateWinner();
        assertEquals(controller.getWinner(), WINNER_CPU);
        // Removes the remaining enemy, this is equivalent that all assigned characters are k.o.,
        // if this happens in the game by any way
        controller.removeAssignedEnemy(controllerEnemy3);
        controller.updateWinner();
        assertEquals(controller.getWinner(), WINNER_TIE);
        // Adds an ready for combat player, this is equivalent that the player has won
        controller.assignToPlayer(controllerEngineer);
        controller.updateWinner();
        assertEquals(controller.getWinner(), WINNER_PLAYER);
    }

    /**
     * Test for enqueuing manager controller methods, this test uses unequipped characters to make
     * the test faster.
     */
    @Test
    void enqueueingTest() {
        // The queue starts empty
        assertTrue(controller.isTurnsQueueEmpty());
        assertNull(controller.peekWaitTurnQueueHead());
        assertNull(controller.getCurrentTurnCharacter());
        // At attempt of turn end nothing changes
        controller.turnEnd();
        assertNull(controller.peekWaitTurnQueueHead());
        // Adds an engineer and tests that it is the first character in the queue
        controller.waitEnqueueForTurn(controllerEngineer);
        threadWaitEpsilon();
        assertFalse(controller.isTurnsQueueEmpty());
        assertEquals(controller.getCurrentTurnCharacter(), controllerEngineer);
        assertEquals(controller.peekWaitTurnQueueHead(), controllerEngineer);
        // Adds a knight and tests that the engineer stills being the first character in queue
        controller.waitEnqueueForTurn(controllerKnight);
        threadWaitEpsilon();
        assertFalse(controller.isTurnsQueueEmpty());
        assertEquals(controller.peekWaitTurnQueueHead(), controllerEngineer);
        // Ends turn of the first character (engineer) and checks that the new first element is
        // knight and it's the current turn of nobody
        System.out.println(controller.getCurrentTurnCharacter());
        controller.turnEnd();
        System.out.println(controller.getCurrentTurnCharacter());
        assertFalse(controller.isTurnsQueueEmpty());
        assertNull(controller.getCurrentTurnCharacter());
        assertEquals(controller.peekWaitTurnQueueHead(), controllerKnight);
        // Starts the turn of knight
        controller.turnStart();
        assertEquals(controller.getCurrentTurnCharacter(), controllerKnight);
        // Dequeue the knight and checks that the queue is left empty
        controller.turnEnd();
        assertTrue(controller.isTurnsQueueEmpty());
        assertNull(controller.peekWaitTurnQueueHead());
    }

    /**
     * Turn dynamics test
     */
    @Test
    public void turnsTest() {

    }

    /**
     * Waits an epsilon time (epsilonWaitTurnTest) before continuing the execution
     */
    private void threadWaitEpsilon() {
        try {
            Thread.sleep(epsilonWaitTurnTest);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
